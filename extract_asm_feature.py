"""
TODO:其实里面的字符串资源也是一种特别重要的特征，看有没有方法导出到特征里面
"""
import os
import numpy as np
from multiprocessing import Pool
from csv import writer

import pandas as pd

BASE_DIR = "/media/xueshan/WD_BLACK/cybersecurity/malaware"
# BASE_DIR = "/home/xueshan/temp/malaware"
TRAIN_DIR = os.path.join(BASE_DIR, "train")
TEST_DIR = os.path.join(BASE_DIR, "test")

DATA_OUT_DIR = os.path.join(BASE_DIR, "data_out")

EXAMPLE_EXAMPLE_DIR = os.path.join(BASE_DIR, "dataSample")
EXAMPLE_ASM_FILE = os.path.join(BASE_DIR, "train", "7rneDC6Ng10vEPuicRWV.asm")
EXAMPLE_BYTES_FILE = os.path.join(BASE_DIR, "dataSample", "0ACDbR5M3ZhBJajygTuf.bytes")

SAPMLE_DIR = TRAIN_DIR

keywords = ['Virtual', 'Offset', 'loc', 'Import', 'Imports', 'var', 'Forwarder', 'UINT', 'LONG', 'BOOL', 'WORD',
            'BYTES', 'large', 'short', 'dd', 'db', 'dw', 'XREF', 'ptr', 'DATA', 'FUNCTION', 'extrn', 'byte', 'word',
            'dword', 'char', 'DWORD', 'stdcall', 'arg', 'locret', 'asc', 'align', 'WinMain', 'unk', 'cookie', 'off',
            'nullsub', 'DllEntryPoint', 'System32', 'dll', 'CHUNK', 'BASS', 'HMENU', 'DLL', 'LPWSTR', 'void', 'HRESULT',
            'HDC', 'LRESULT', 'HANDLE', 'HWND', 'LPSTR', 'int', 'HLOCAL', 'FARPROC', 'ATOM', 'HMODULE', 'WPARAM',
            'HGLOBAL', 'entry', 'rva', 'COLLAPSED', 'config', 'exe', 'Software', 'CurrentVersion', '__imp_', 'INT_PTR',
            'UINT_PTR', '---Seperator', 'PCCTL_CONTEXT', '__IMPORT_', 'INTERNET_STATUS_CALLBACK', '.rdata:', '.data:',
            '.text:', 'case', 'installdir', 'market', 'microsoft', 'policies', 'proc', 'scrollwindow', 'search', 'trap',
            'visualc', '___security_cookie', 'assume', 'callvirtualalloc', 'exportedentry', 'hardware',
            'hkey_current_user', 'hkey_local_machine', 'sp-analysisfailed', 'unableto']
known_sections = ['.text', '.data', '.bss', '.rdata', '.edata', '.idata', '.rsrc', '.tls', '.reloc']
registers = ['edx', 'esi', 'es', 'fs', 'ds', 'ss', 'gs', 'cs', 'ah', 'al',
             'ax', 'bh', 'bl', 'bx', 'ch', 'cl', 'cx', 'dh', 'dl', 'dx',
             'eax', 'ebp', 'ebx', 'ecx', 'edi', 'esp']

opcodes = ['add', 'al', 'bt', 'call', 'cdq', 'cld', 'cli', 'cmc', 'cmp', 'const', 'cwd', 'daa', 'db'
    , 'dd', 'dec', 'dw', 'endp', 'ends', 'faddp', 'fchs', 'fdiv', 'fdivp', 'fdivr', 'fild'
    , 'fistp', 'fld', 'fstcw', 'fstcwimul', 'fstp', 'fword', 'fxch', 'imul', 'in', 'inc'
    , 'ins', 'int', 'jb', 'je', 'jg', 'jge', 'jl', 'jmp', 'jnb', 'jno', 'jnz', 'jo', 'jz'
    , 'lea', 'loope', 'mov', 'movzx', 'mul', 'near', 'neg', 'not', 'or', 'out', 'outs'
    , 'pop', 'popf', 'proc', 'push', 'pushf', 'rcl', 'rcr', 'rdtsc', 'rep', 'ret', 'retn'
    , 'rol', 'ror', 'sal', 'sar', 'sbb', 'scas', 'setb', 'setle', 'setnle', 'setnz'
    , 'setz', 'shl', 'shld', 'shr', 'sidt', 'stc', 'std', 'sti', 'stos', 'sub', 'test'
    , 'wait', 'xchg', 'xor']


##############################################

def count_asm_registers(asm_code):
    """
    统计一个asm文件里面在registers里面的汇编寄存器出现了多少次，这是什么意思呢？估计其实也没什么意思，就是把这个特征统计出来而已
    :param asm_code:
    :return:
    """
    registers_values = [0] * len(registers)
    for row in asm_code:
        parts = row.replace(',', ' ').replace('+', ' ').replace('*', ' ').replace('[', ' ').replace(']', ' ') \
            .replace('-', ' ').split()
        # print(parts)
        for register in registers:
            registers_values[registers.index(register)] += parts.count(register)
    return registers_values


def count_asm_opcodes(asm_code):
    """
    统计一个asm文件里面在opcodes里面的汇编操作码出现了多少次
    :param asm_code:
    :return:
    """
    opcodes_values = [0] * len(opcodes)
    for row in asm_code:
        parts = row.split()

        for opcode in opcodes:
            if opcode in parts:
                opcodes_values[opcodes.index(opcode)] += 1
                break
    return opcodes_values


def count_asm_APIs(asm_code, apis):
    """
    直接找函数名，也就是程序中用到了的函数名出现的次数，包括导入表中的
    :param asm_code:
    :param apis:
    :return:
    """
    apis_values = [0] * len(apis)
    for row in asm_code:
        for i in range(len(apis)):
            if apis[i] in row:
                apis_values[i] += 1
                break
    return apis_values


def count_asm_misc(asm_code):
    """
    根据关键词找一些有的没的的信息
    :param asm_code:
    :return:
    """
    keywords_values = [0] * len(keywords)
    for row in asm_code:
        for i in range(len(keywords)):
            if keywords[i] in row:
                keywords_values[i] += 1
                break
    return keywords_values


##############################################
def main_work():
    """
    :return:
    """

    extract_asm_features([EXAMPLE_ASM_FILE])
    exit(0)
    n_jobs = 12
    arguments = []

    file_lst = [f for f in os.listdir(TRAIN_DIR) if f.endswith(".asm")]
    print("total samples:", len(file_lst))
    segments = np.linspace(0, len(file_lst), n_jobs + 1).astype(int)
    for idx, i in enumerate(range(n_jobs)):
        arguments.append(file_lst[segments[i]:segments[i + 1]])
        print(idx, ":", segments[i], "->", segments[i + 1], len(arguments[-1]))

    p = Pool(n_jobs)
    p.map(extract_asm_features, arguments)


def extract_asm_features(tfiles):
    pid = os.getpid()
    print('Process id:', pid)
    if SAPMLE_DIR == TRAIN_DIR:
        feature_file = os.path.join(DATA_OUT_DIR,
                                    str(pid) + '-malware-features-asm.csv')  # Windows API, symbols, registers, opcodes, etc...
    elif SAPMLE_DIR == TEST_DIR:
        feature_file = os.path.join(DATA_OUT_DIR,
                                    str(pid) + '-malware-features_test-asm.csv')  # Windows API, symbols, registers, opcodes, etc...
    else:
        raise Exception("unkown sample dir", SAPMLE_DIR)

    print('feature file:', feature_file)

    fapi = open(os.path.join(BASE_DIR, "APIs.txt"))
    defined_apis = fapi.readlines()
    defined_apis = defined_apis[0].split(',')

    asm_files = [i for i in tfiles if '.asm' in i]
    ftot = len(asm_files)

    feature_counts = []
    with open(feature_file, 'w') as f:
        # write the csv header
        fw = writer(f)
        colnames = ['filename'] + registers + opcodes + defined_apis + keywords
        fw.writerow(colnames)

        for idx, fname in enumerate(asm_files):
            # print("processing:", os.path.join(TRAIN_DIR, fname))
            # 里面有很多unicode字符，需要unicode_escape来解码
            try:
                fasm = open(os.path.join(TRAIN_DIR, fname), 'r', errors='ignore')
                content = fasm.readlines()
            except Exception as err:
                print("read err:", fname)
                raise err
            #
            reg_vals = count_asm_registers(content)
            opc_vals = count_asm_opcodes(content)
            api_vals = count_asm_APIs(content, defined_apis)
            # sec_vals = count_asm_sections(content)
            mis_vals = count_asm_misc(content)
            count_vals = reg_vals + opc_vals + api_vals + mis_vals

            feature_counts.append([fname[:fname.find('.asm')]] + count_vals)

            fasm.close()
            # Writing rows after every 10 files processed
            if (idx + 1) % 10 == 0:
                print(pid, idx + 1, 'of', ftot, 'files processed.')
                fw.writerows(feature_counts)
                feature_counts = []

        # Writing remaining files
        if len(feature_counts) > 0:
            fw.writerows(feature_counts)
            feature_counts = []


def concact_result():
    rel_files = [f for f in os.listdir(DATA_OUT_DIR) if f.endswith("-malware-features-asm.csv")]

    df: pd.DataFrame = None
    for rel_file in rel_files:
        tdf = pd.read_csv(os.path.join(DATA_OUT_DIR, rel_file))
        if len(tdf) > 0:
            if df is None:
                df = tdf
            else:
                df = pd.concat([df, tdf], axis=0)

    # print(df)
    df.to_csv(os.path.join(DATA_OUT_DIR, "train-malware-features-asm.csv"))


if __name__ == '__main__':
    # ExtraTreesClassifier()
    concact_result()
